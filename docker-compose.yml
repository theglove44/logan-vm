name: mediaserver
services:
  # jellyfin:
  #   image: jellyfin/jellyfin:latest
  #   container_name: jellyfin
  #   user: "${PUID}:${PGID}"
  #   environment:
  #     - TZ=${TZ}
  #     # Reverse-proxy ready (optional labels for later)
  #     - JELLYFIN_PublishedServerUrl=${HOST_LAN}
  #   volumes:
  #     - /opt/mediaserver/jellyfin/config:/config
  #     - /opt/mediaserver/jellyfin/cache:/cache
  #     - /mnt/storage/data/media:/media
  #   ports:
  #     - "8096:8096"    # HTTP
  #     # - "8920:8920"  # HTTPS (enable if you terminate TLS here)
  #     # DLNA/UPnP optional:
  #     # - "1900:1900/udp"
  #     # - "7359:7359/udp"
  #   labels:
  #     - "com.centurylinklabs.watchtower.enable=true"
  #     - "wud.watch=true"
  #   networks:
  #     - default
  #   devices:
  #     - /dev/dri:/dev/dri
  #   group_add:
  #     - "992"
  #     - "44"
  #   restart: unless-stopped
  #   healthcheck:
  #     test: ["CMD", "curl", "-f", "http://localhost:8096/health"]
  #     interval: 30s
  #     timeout: 5s
  #     retries: 5

  plex:
    image: lscr.io/linuxserver/plex:latest
    container_name: plex
    network_mode: "host"  # Plex works best on host network; avoids port juggling
    user: "${PUID}:${PGID}"
    environment:
      - TZ=Europe/London                # <-- set your timezone
      # Run the official image as the same host user/group for correct file perms
      - PLEX_UID=${PUID}
      - PLEX_GID=${PGID}
      - UMASK=002
      # Optional: claim token to (re)claim the server after auth resets
      # Get one from https://plex.tv/claim while logged in (2FA enabled)
      # Tip: set `PLEX_CLAIM=claim-xxxx` in `.env`, then restart just the plex service
      - PLEX_CLAIM=${PLEX_CLAIM:-}
      # Force clients (esp. tvOS/web) to prefer the public domain + local fallback
      - ADVERTISE_IP=https://plex.w0lverine.uk,http://10.0.0.79:32400

    volumes:
      - /opt/mediaserver/plex/config:/config     # <-- change to your preferred config path
      - /mnt/storage/data/media:/media                # <-- root of your media library (or split by type)
      # Optional: dedicate a fast transcode scratch dir (SSD/tmpfs)
      - /opt/mediaserver/plex/transcode:/transcode
    devices:
      - /dev/dri:/dev/dri               # <-- enables Intel Quick Sync (iGPU) via VAAPI
    # Improves device access for some hosts; harmless otherwise
    group_add:
      - "992"
      - "44"
    labels:
      - "wud.watch=true"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "bash", "-O", "extglob", "-c", "curl -fsS http://127.0.0.1:32400/identity || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 40s

  overseerr:
    image: lscr.io/linuxserver/overseerr:latest
    container_name: overseerr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
      # Optional: if you run through a reverse proxy at a subpath, set this
      # - URL_BASE=/overseerr
    volumes:
      - /opt/mediaserver/overseerr:/config
    ports:
      - "5155:5055"        # host:container (avoid clash with jellyseerr)
    networks:
      - default
    restart: unless-stopped
    extra_hosts:
      - "host.docker.internal:host-gateway"  # <-- map this name to the Docker host
    depends_on:
      # not strictly required, but if you want the UI to see *arr* immediately:
      - sonarr
      - radarr
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5055/api/v1/status"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 30s

  sabnzbd:
    image: lscr.io/linuxserver/sabnzbd:latest
    container_name: sabnzbd
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
    volumes:
      - /opt/mediaserver/sabnzbd:/config
      - /opt/mediaserver/sabnzbd/incomplete:/incomplete
      - /mnt/storage/data/:/data
      - /opt/mediaserver/scripts:/scripts:ro
    ports:
      - "8080:8080"
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api?mode=version"]
      interval: 30s
      timeout: 5s
      retries: 10

  prowlarr:
    image: lscr.io/linuxserver/prowlarr:latest
    container_name: prowlarr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
    volumes:
      - /opt/mediaserver/prowlarr:/config
      - /mnt/storage/data:/data
    ports:
      - "9696:9696"
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9696/"]
      interval: 30s
      timeout: 5s
      retries: 10

  sonarr:
    image: lscr.io/linuxserver/sonarr:latest
    container_name: sonarr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
      - SONARR_API_KEY=${HOMEPAGE_VAR_SONARR_API_KEY}  # expose API key for health check
    volumes:
      - /opt/mediaserver/sonarr:/config
      - /mnt/storage/data:/data
      - /mnt/storage/data/media:/media
    ports:
      - "8989:8989"
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
      - "wud.watch=true"
    networks:
      - default
    restart: unless-stopped
    depends_on:
      - sabnzbd
      - prowlarr
    healthcheck:
      test: ["CMD", "bash", "-O", "extglob", "-c", "curl -fsS 'http://localhost:8989/api/v3/system/status?apikey=c13ee519d6004c5a94df8c8158c05b71' >/dev/null"]
      interval: 30s
      timeout: 5s
      retries: 10

  radarr:
    image: lscr.io/linuxserver/radarr:latest
    container_name: radarr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
      - RADARR_API_KEY=${HOMEPAGE_VAR_RADARR_API_KEY}  # expose API key for health check
    volumes:
      - /opt/mediaserver/radarr:/config
      - /mnt/storage/data:/data
      - /mnt/storage/data/media:/media
    ports:
      - "7878:7878"
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
      - "wud.watch=true"
    networks:
      - default
    restart: unless-stopped
    depends_on:
      - sabnzbd
      - prowlarr
    healthcheck:
      test: ["CMD", "bash", "-O", "extglob", "-c", "curl -fsS 'http://localhost:7878/api/v3/system/status?apikey=eb12ce387963477b826ed2bbba0aa6cd' >/dev/null"]
      interval: 30s
      timeout: 5s
      retries: 10

  bazarr:
    image: lscr.io/linuxserver/bazarr:latest
    container_name: bazarr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
    volumes:
      - /opt/mediaserver/bazarr:/config
      - /mnt/storage/data/media:/media
    ports:
      - "6767:6767"
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
    restart: unless-stopped
    depends_on:
      - sonarr
      - radarr
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6767/system/status"]
      interval: 30s
      timeout: 5s
      retries: 10

  recyclarr:
    image: ghcr.io/recyclarr/recyclarr:latest
    container_name: recyclarr
    user: "${PUID}:${PGID}"
    environment:
      - TZ=${TZ}
    volumes:
      - /opt/mediaserver/recyclarr:/config
    # No ports; run via cron-like schedule below using restart policy + command
    command: ["sync"]
    restart: "no"  # We'll run on-demand with: docker compose run --rm recyclarr

  # jellyseerr:
  #   image: fallenbagel/jellyseerr:latest
  #   container_name: jellyseerr
  #   environment:
  #     - LOG_LEVEL=info
  #     - TZ=${TZ}
  #   volumes:
  #     - /opt/mediaserver/jellyseerr:/app/config
  #   ports:
  #     - "5055:5055"
  #   restart: unless-stopped
  #   depends_on:
  #     - jellyfin
  #   networks:
  #     - default

  tautulli:
    image: lscr.io/linuxserver/tautulli:latest
    container_name: tautulli
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
    volumes:
      - /opt/mediaserver/tautulli:/config
    ports:
      - "8181:8181"
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
    restart: unless-stopped
    depends_on:
      - plex
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8181/" ]
      interval: 30s
      timeout: 5s
      retries: 10

  homepage:
    image: ghcr.io/gethomepage/homepage:v0.9.13
    container_name: homepage
    user: "0:999"  # root:docker group - required for Docker socket access
    environment:
      - TZ=${TZ}
      # Host validation - allow requests from LAN IP (include port since exposed as 3001)
      - HOMEPAGE_ALLOWED_HOSTS=10.0.0.79:3001
      # Pass through API keys for widgets
      - HOMEPAGE_VAR_SONARR_API_KEY=${HOMEPAGE_VAR_SONARR_API_KEY}
      - HOMEPAGE_VAR_RADARR_API_KEY=${HOMEPAGE_VAR_RADARR_API_KEY}
      - HOMEPAGE_VAR_SAB_API_KEY=${HOMEPAGE_VAR_SAB_API_KEY}
      - HOMEPAGE_VAR_TAUTULLI_API_KEY=${HOMEPAGE_VAR_TAUTULLI_API_KEY}
      - HOMEPAGE_VAR_PLEX_TOKEN=${HOMEPAGE_VAR_PLEX_TOKEN}
      # - JELLYFIN_TOKEN=${JELLYFIN_TOKEN}
      # - HOMEPAGE_VAR_JELLYFIN_KEY=${JELLYFIN_TOKEN}
    volumes:
      - /opt/mediaserver/homepage/config:/app/config
      - /var/run/docker.sock:/var/run/docker.sock:ro
    ports:
      - "3001:3000"
    networks:
      - default
    restart: unless-stopped
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
    depends_on:
      # - jellyfin
      - plex
      - sonarr
      - radarr
      - sabnzbd
      - prowlarr
      - tautulli
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/"]
      interval: 30s
      timeout: 5s
      retries: 10

  apprise:
    image: lscr.io/linuxserver/apprise-api:latest
    container_name: apprise
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - /opt/mediaserver/apprise/config:/config
      - /opt/mediaserver/apprise/attachments:/attachments
    ports:
      - "8338:8000"
    networks:
      - default
    restart: unless-stopped
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/"]
      interval: 30s
      timeout: 5s
      retries: 10

  docker-socket-proxy:
    image: tecnativa/docker-socket-proxy:latest
    container_name: docker-socket-proxy
    environment:
      # Grant read-only access to necessary APIs for LoggiFly
      - CONTAINERS=1
      - EVENTS=1
      - IMAGES=1
      - INFO=1
      - LOG=1
      - NETWORKS=1
      - SERVICES=1
      - SWARM=1
      - VERSION=1
      # Disable write operations for security
      - POST=0
      - ALLOW_START=0
      - ALLOW_STOP=0
      - ALLOW_RESTART=0
    volumes:
      # Mount Docker socket (read-only)
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - default
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "-q", "-O-", "http://localhost:2375/_ping"]
      interval: 30s
      timeout: 5s
      retries: 3

  loggifly:
    image: ghcr.io/clemcer/loggifly:latest
    container_name: loggifly
    # Connect to Docker via socket-proxy (secure, read-only access)
    environment:
      - TZ=${TZ}
      - DOCKER_HOST=tcp://docker-socket-proxy:2375
      - CONFIG_FILE=/config/config.yaml
      - LOG_LEVEL=INFO
    volumes:
      # LoggiFly configuration
      - /opt/mediaserver/loggifly/config:/config
      # Log file access (read-only)
      - /opt/mediaserver/sonarr/logs:/logs/sonarr:ro
      - /opt/mediaserver/radarr/logs:/logs/radarr:ro
      - /opt/mediaserver/prowlarr/logs:/logs/prowlarr:ro
      - /opt/mediaserver/sabnzbd/logs:/logs/sabnzbd:ro
      - /opt/mediaserver/overseerr/logs:/logs/overseerr:ro
      - /opt/mediaserver/tautulli/logs:/logs/tautulli:ro
      - /opt/mediaserver/homepage/config/logs:/logs/homepage:ro
      - /opt/mediaserver/bazarr/logs:/logs/bazarr:ro
      - /opt/mediaserver/caddy/logs:/logs/caddy:ro
      - /opt/mediaserver/plex/config/Library/Application Support/Plex Media Server/Logs:/logs/plex:ro
    networks:
      - default
    restart: unless-stopped
    depends_on:
      - apprise
      - docker-socket-proxy
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
    mem_limit: 256m
    healthcheck:
      test: ["CMD", "python", "-c", "import os; exit(0 if os.path.exists('/config/config.yaml') else 1)"]
      interval: 60s
      timeout: 5s
      retries: 3
      start_period: 15s

  # jellyplex-watched:
  #   image: luigi311/jellyplex-watched:latest
  #   container_name: jellyplex-watched
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #     # App config
  #     - DRYRUN=False
  #     - DEBUG_LEVEL=DEBUG
  #     - RUN_ONLY_ONCE=False
  #     - SLEEP_DURATION=300
  #     # Persist logs/marks to mounted path
  #     - LOG_FILE=/config/log.log
  #     - MARK_FILE=/config/mark.log
  #     # Plex (host network container) â€” access via host gateway
  #     - PLEX_BASEURL=https://plex.w0lverine.uk
  #     - PLEX_TOKEN=${HOMEPAGE_VAR_PLEX_TOKEN}
  #     # Jellyfin (same compose network) â€” access via service name
  #     # - JELLYFIN_BASEURL=https://jellyfin.w0lverine.uk
  #     # - JELLYFIN_TOKEN=${JELLYFIN_TOKEN}
  #     # Only Plex <-> Jellyfin syncing enabled by default
  #     - SYNC_FROM_PLEX_TO_PLEX=False
  #     - SYNC_FROM_PLEX_TO_EMBY=False
  #     - SYNC_FROM_JELLYFIN_TO_EMBY=False
  #     - SYNC_FROM_EMBY_TO_PLEX=False
  #     - SYNC_FROM_EMBY_TO_JELLYFIN=False
  #     - SYNC_FROM_EMBY_TO_EMBY=False
  #   volumes:
  #     - /opt/mediaserver/jellyplex-watched:/config
  #   extra_hosts:
  #     - "host.docker.internal:host-gateway"
  #     - "plex.w0lverine.uk:172.18.0.16"
  #     # - "jellyfin.w0lverine.uk:172.18.0.16"
  #   restart: unless-stopped
  #   depends_on:
  #     - plex
  #     # - jellyfin
  #   labels:
  #     - "com.centurylinklabs.watchtower.enable=true"

  fail2ban:
    image: crazymax/fail2ban:latest
    container_name: fail2ban
    network_mode: "host"          # manage iptables in the host namespace
    cap_add:
      - NET_ADMIN
      - NET_RAW
    environment:
      - TZ=${TZ}
      - F2B_LOG_TARGET=STDOUT
      - F2B_LOG_LEVEL=INFO
    volumes:
      # Fail2ban config (filters, jails, state)
      - ./security/fail2ban:/data
      # Map the current Plex log file to a space-free path inside the container
      - /opt/mediaserver/plex/config/Library/Application Support/Plex Media Server/Logs/Plex Media Server.log:/var/log/plexms/plexms.log:ro
    restart: unless-stopped

  pihole:
    image: pihole/pihole:latest
    container_name: pihole
    hostname: pihole
    environment:
      - TZ=${TZ}
      - WEBPASSWORD=${PIHOLE_WEBPASSWORD:-changeme}
      - ServerIP=${HOST_LAN}
      - VIRTUAL_HOST=pihole.${HOST_LAN}
      - DNSMASQ_LISTENING=all
      - PIHOLE_DNS_=1.1.1.1;1.0.0.1
      - FTLCONF_dns_listeningMode=all
    volumes:
      - /opt/mediaserver/pihole/etc-pihole:/etc/pihole
      - /opt/mediaserver/pihole/etc-dnsmasq.d:/etc/dnsmasq.d
    ports:
      - "53:53/tcp"
      - "53:53/udp"
      - "8088:80"
    restart: unless-stopped

  watchtower:
    image: nickfedor/watchtower:latest
    container_name: watchtower
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - TZ=Europe/London
      - WATCHTOWER_NOTIFICATIONS=shoutrrr
      - WATCHTOWER_NOTIFICATION_URL=http://apprise:8000/notify?tag=updates
      - WATCHTOWER_NOTIFICATIONS_LEVEL=info        # startup + updates + warnings/errors
      - WATCHTOWER_NOTIFICATION_REPORT=true        # send a summary every run (even 0 updates)
      - WATCHTOWER_NOTIFICATION_TITLE_TAG=watchtower@mediaserver
      - WATCHTOWER_NO_STARTUP_MESSAGE=true         # suppress the initial "updates on <id>" line
      # Always send a readable summary with names (even when 0 updates)
      - 'WATCHTOWER_NOTIFICATION_TEMPLATE={{- if .Report -}}{{- with .Report -}}{{len .Scanned}} scanned, {{len .Updated}} updated, {{len .Failed}} failed{{- if .Updated}}{{println}}Updated: {{- range $$i, $$u := .Updated}}{{- if $$i}}, {{end -}}{{$$u.Name}}{{- end}}{{- end -}}{{- if .Failed}}{{println}}Failed: {{- range $$i, $$f := .Failed}}{{- if $$i}}, {{end -}}{{$$f.Name}}{{- end}}{{- end -}}{{- if .Skipped}}{{println}}Skipped: {{- range $$i, $$s := .Skipped}}{{- if $$i}}, {{end -}}{{$$s.Name}}{{- end}}{{- end -}}{{- end -}}{{- end -}}'
      - WATCHTOWER_INCLUDE_RESTARTING=true         # scan restarting containers too
      - WATCHTOWER_INCLUDE_STOPPED=true            # scan stopped containers for image updates
    command: >
      --cleanup
      --rolling-restart
      --stop-timeout 60s
      --schedule "0 0 4 * * *"
    restart: unless-stopped

  wud:
    image: getwud/wud:latest
    container_name: wud
    environment:
      - TZ=${TZ}
      # Watcher: check every 6 hours (offset from Watchtower's 4 AM daily run)
      - WUD_WATCHER_LOCAL_SOCKET=/var/run/docker.sock
      - WUD_WATCHER_LOCAL_CRON=0 */6 * * *
      # Discord notifications (individual messages per container update)
      - WUD_TRIGGER_DISCORD_1_URL=http://apprise:8000/notify?tag=updates
      - WUD_TRIGGER_DISCORD_1_BOTUSERNAME=WUD
      - WUD_TRIGGER_DISCORD_1_MODE=simple
      - WUD_TRIGGER_DISCORD_1_ONCE=false
      # Optional: auto-prune old images after check
      - WUD_TRIGGER_DOCKER_LOCAL_PRUNE=true
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    ports:
      - "3000:3000"
    networks:
      - default
    restart: unless-stopped

  backup:
    image: ghcr.io/borgmatic-collective/borgmatic:1.8.12
    container_name: mediaserver-backup
    restart: unless-stopped
    environment:
      TZ: "Europe/London"
      BORG_REPOSITORY: "/mnt/backup/mediaserver"   # ðŸ‘ˆ backups stored here
      BORG_PASSPHRASE: "${BORG_PASSPHRASE:?set in .env}"
    volumes:
      # Borgmatic config & hooks
      - ./backup/config:/etc/borgmatic:ro
      # Provide cron schedule to the container
      - ./backup/config/crontab.txt:/etc/crontabs/root:ro
      # Borg runtime state
      - borg-cache:/root/.cache/borg
      - borg-config:/root/.config/borg

      # Sources to back up (read-only)
      - .:/backup/mediaserver:ro

      # Mount backup target from host
      - /mnt/backup:/mnt/backup

    read_only: true
    tmpfs:
      - /tmp:rw,exec
      - /run:rw,exec

  rclone_backup:
    image: alpine:3.20
    container_name: rclone_backup
    restart: unless-stopped
    environment:
      - TZ=${TZ}
      - RCLONE_CONFIG=/etc/rclone/rclone.conf
    volumes:
      - /mnt/backup/mediaserver:/data:ro
      - /opt/mediaserver/backup/rclone:/config/rclone
      - ./backup/rclone/crontab.txt:/etc/crontabs/root:ro
    command: >
      sh -c "apk add --no-cache rclone tzdata >/dev/null \
      && mkdir -p /etc/rclone /root/.config/rclone \
      && if [ -f /config/rclone/rclone.conf ]; then cp /config/rclone/rclone.conf /etc/rclone/rclone.conf && cp /config/rclone/rclone.conf /root/.config/rclone/rclone.conf; else echo 'rclone.conf missing; run rclone config'; fi \
      && crond -f -d 8"

  caddy:
    image: caddy:latest
    container_name: caddy
    user: "${PUID}:${PGID}"
    environment:
      - TZ=${TZ}
      - CADDY_ADMIN_PASSWORD_HASH=${CADDY_ADMIN_PASSWORD_HASH}
    volumes:
      - /opt/mediaserver/caddy/config/Caddyfile:/etc/caddy/Caddyfile:ro
      - /opt/mediaserver/caddy/data:/data
      - /opt/mediaserver/caddy/logs:/var/log/caddy
    ports:
      - "80:80"
      - "443:443"
    networks:
      - default
    extra_hosts:
      - "host.docker.internal:host-gateway"
    restart: unless-stopped
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
      - "wud.watch=true"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:2019/config/"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  filebrowser:
    image: filebrowser/filebrowser:latest
    container_name: filebrowser
    user: "${PUID}:${PGID}"
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
    volumes:
      - /opt/mediaserver/filebrowser:/config
      - /opt/mediaserver/filebrowser/database.db:/database/filebrowser.db
      - /mnt/storage:/srv
    ports:
      - "8095:80"
    networks:
      - default
    restart: unless-stopped
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
      - "wud.watch=true"
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 5s
      retries: 10
      start_period: 10s

  discord-bot:
    build: /opt/mediaserver/discord-bot
    container_name: discord-claude-bot
    restart: unless-stopped
    environment:
      - DISCORD_BOT_TOKEN=${DISCORD_BOT_TOKEN}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - ALLOWED_USERS=${ALLOWED_USERS:-}
      - LOG_LEVEL=INFO
    volumes:
      - /var/log:/var/log:ro
      - /opt/mediaserver:/opt/mediaserver:ro
      - /mnt/storage:/mnt/storage:ro
      - /opt/mediaserver/discord-bot/logs:/app/logs
    networks:
      - default
    labels:
      - "com.centurylinklabs.watchtower.enable=true"
      - "wud.watch=true"
    healthcheck:
      test: ["CMD", "python3", "-c", "import os; exit(0 if os.path.exists('/app/logs/bot.log') else 1)"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

volumes:
  borg-cache:
  borg-config:


 
networks:
  default:
    name: media_net
    external: true
    # Keeps LAN/Tailscale exposure simple via host IP bindings above

# Note:
# /mnt/storage/data is an existing NFS mount on the host. We bind-mount that into containers.
# That keeps permissions consistent with PUID/PGID and avoids Docker's NFS volume caveats.
